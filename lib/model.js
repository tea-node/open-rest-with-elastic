const Util = require('util');
const Utils = require('./utils');
const Instance = require('./instance');
const DataTypes = require('./data-types');

/* eslint func-names: 0 */

const addOptionalClassMethods = function () {
  const self = this;
  Utils._.each(this.options.classMethods || {}, (fct, name) => { self[name] = fct; });
};

const addDefaultAttributes = function () {
  const self = this;
  const tail = {};
  let head = {};

  // Add id if no primary key was manually added to definition
  // Can't use this.primaryKeys here, since this function is called before PKs are identified
  if (!Utils._.some(this.rawAttributes, 'primaryKey')) {
    if ('id' in this.rawAttributes) {
      // Something is fishy here!
      throw new Error(`A column called 'id' was added to the attributes of '${this.typeName}' but not marked with 'primaryKey: true'`);
    }

    head = {
      id: {
        type: DataTypes.LONG,
        allowNull: false,
        primaryKey: true,
        _autoGenerated: true,
      },
    };
  }

  if (this._timestampAttributes.createdAt) {
    tail[this._timestampAttributes.createdAt] = {
      type: DataTypes.DATE,
      allowNull: false,
      _autoGenerated: true,
    };
  }
  if (this._timestampAttributes.updatedAt) {
    tail[this._timestampAttributes.updatedAt] = {
      type: DataTypes.DATE,
      allowNull: false,
      _autoGenerated: true,
    };
  }

  if (this._timestampAttributes.deletedAt) {
    tail[this._timestampAttributes.deletedAt] = {
      type: DataTypes.DATE,
      _autoGenerated: true,
    };
  }

  const existingAttributes = Utils._.clone(self.rawAttributes);
  self.rawAttributes = {};

  Utils._.each(head, (value, attr) => {
    self.rawAttributes[attr] = value;
  });

  Utils._.each(existingAttributes, (value, attr) => {
    self.rawAttributes[attr] = value;
  });

  Utils._.each(tail, (value, attr) => {
    if (Utils._.isUndefined(self.rawAttributes[attr])) {
      self.rawAttributes[attr] = value;
    }
  });

  if (!Object.keys(this.primaryKeys).length) {
    self.primaryKeys.id = self.rawAttributes.id;
  }
};

function Model(name, attributes, options) {
  this.options = Utils._.extend({
    timestamps: true,
    underscored: false,
    instanceMethods: {},
    classMethods: {},
  }, options);

  this.name = name;
  this.attributes = attributes;
  this.client = options.client;

  // index, type name
  this.indexName = options.indexName || name;
  this.typeName = options.typeName || '_doc';

  const attrs = Utils._.mapValues(attributes, (attribute, attrName) => {
    let attr = attribute;

    if (!Utils._.isPlainObject(attribute)) {
      attr = { type: attribute };
    }

    attr = Utils.normalizeAttribute(attribute);

    if (attribute.type === undefined) {
      throw new Error(`Unrecognized data type for field ${attrName}`);
    }

    return attr;
  });

  this.attributes = attrs;
  this.rawAttributes = attrs;

  const _sourceExclude = options.excludeCols || [];
  const _sourceCols = options.includeCols || Object.keys(this.rawAttributes);

  this._source = true;
  this._sourceInclude = _sourceCols;
  this._sourceExclude = _sourceCols.filter(col => !_sourceExclude.includes(col));
}

Model.prototype.toString = function () {
  return `[object ElasticSearchModel:${this.name}]`;
};

/* eslint no-underscore-dangle: 0 */
Model.prototype.init = () => {
  const self = this;
  this.primaryKeys = {};
  // Setup names of timestamp attributes
  this._timestampAttributes = {};

  if (this.options.timestamps) {
    if (this.options.createdAt !== false) {
      this._timestampAttributes.createdAt = this.options.createdAt || Utils.underscoredIf('createdAt', this.options.underscored);
    }
    if (this.options.updatedAt !== false) {
      this._timestampAttributes.updatedAt = this.options.updatedAt || Utils.underscoredIf('updatedAt', this.options.underscored);
    }
    if (this.options.paranoid && this.options.deletedAt !== false) {
      this._timestampAttributes.deletedAt = this.options.deletedAt || Utils.underscoredIf('deletedAt', this.options.underscored);
    }
  }

  // Add head and tail default attributes (id, timestamps)
  addOptionalClassMethods.call(this);

  // Instance prototype
  this.Instance = function (...args) {
    Instance.apply(this, args);
  };

  Util.inherits(this.Instance, Instance);

  this._readOnlyAttributes = Utils._.values(this._timestampAttributes);
  this._hasReadOnlyAttributes = this._readOnlyAttributes && this._readOnlyAttributes.length;
  this._isReadOnlyAttribute = Utils._.memoize(key => self._hasReadOnlyAttributes && self._readOnlyAttributes.indexOf(key) !== -1);

  if (this.options.instanceMethods) {
    Utils._.each(this.options.instanceMethods, (fct, name) => {
      self.Instance.prototype[name] = fct;
    });
  }

  addDefaultAttributes.call(this);
  this.refreshAttributes();
};

Model.prototype.refreshAttributes = function () {
  const self = this;
  const attributeManipulation = {};

  this.Instance.prototype._customGetters = {};
  this.Instance.prototype._customSetters = {};

  Utils._.each(['get', 'set'], (type) => {
    const opt = `${type}terMethods`;
    const funcs = Utils._.clone(Utils._.isObject(self.options[opt]) ? self.options[opt] : {});
    const _custom = type === 'get' ? self.Instance.prototype._customGetters : self.Instance.prototype._customSetters;

    Utils._.each(funcs, (method, attribute) => {
      _custom[attribute] = method;

      if (type === 'get') {
        funcs[attribute] = function () {
          return this.get(attribute);
        };
      }
      if (type === 'set') {
        funcs[attribute] = function (value) {
          return this.set(attribute, value);
        };
      }
    });

    Utils._.each(self.rawAttributes, (options, attribute) => {
      if (Object.prototype.hasOwnProperty.call(options, type)) {
        _custom[attribute] = options[type];
      }

      if (type === 'get') {
        funcs[attribute] = function () {
          return this.get(attribute);
        };
      }

      if (type === 'set') {
        funcs[attribute] = function (value) {
          return this.set(attribute, value);
        };
      }
    });

    Utils._.each(funcs, (fct, name) => {
      if (!attributeManipulation[name]) {
        attributeManipulation[name] = {
          configurable: true,
        };
      }
      attributeManipulation[name][type] = fct;
    });
  });

  this._stringAttributes = [];
  this._numberAttributes = [];
  this._dateAttributes = [];
  this._booleanAttributes = [];
  this._binaryAttributes = [];
  this._rangeAttributes = [];
  this._complexAttributes = [];
  this._geoAttributes = [];
  this._specialistedAttributes = [];
  this._virtualAttributes = [];

  this._defaultValues = {};
  this.Instance.prototype.validators = {};

  this.fieldRawAttributesMap = {};

  this.primaryKeys = {};
  self.options.uniqueKeys = {};

  Utils._.each(this.rawAttributes, (definition, name) => {
    definition.type = Utils.normalizeDataType(definition.type);

    definition.Model = self;
    definition.fieldName = name;
    definition._modelAttribute = true;

    if (definition.field === undefined) {
      definition.field = name;
    }

    if (definition.primaryKey === true) {
      self.primaryKeys[name] = definition;
    }

    self.fieldRawAttributesMap[definition.field] = definition;

    if (DataTypes.STRING_TYPES.includes(definition.type)) {
      this._stringAttributes.push(name);
    } else if (DataTypes.NUMBER_TYPES.includes(definition.type)) {
      this._numberAttributes.push(name);
    } else if (DataTypes.DATE_TYPES.includes(definition.type)) {
      this._dateAttributes.push(name);
    } else if (DataTypes.BOOLEAN_TYEPS.includes(definition.type)) {
      this._booleanAttributes.push(name);
    } else if (DataTypes.BINARY_TYPES.includes(definition.type)) {
      this._binaryAttributes.push(name);
    } else if (DataTypes.RANGE_TYEPS.includes(definition.type)) {
      this._rangeAttributes.push(name);
    } else if (DataTypes.COMPLEX_TYPES.includes(definition.type)) {
      this._complexAttributes.push(name);
    } else if (DataTypes.GEO_TYPES.includes(definition.type)) {
      this._geoAttributes.push(name);
    } else if (DataTypes.SPECIALISTED_TYPES.includes(definition.type)) {
      this._specialistedAttributes.push(name);
    } else if (DataTypes.VIRTUAL_TYPES.includes(definition.type)) {
      this._virtualAttributes.push(name);
    }

    if (Object.prototype.hasOwnProperty.call(definition, 'defaultValue')) {
      self._defaultValues[name] = Utils._.partial(Utils.toDefaultValue, definition.defaultValue);
    }

    if (Object.prototype.hasOwnProperty.call(definition, 'unique') && definition.unique !== false) {
      let idxName;

      if (typeof definition.unique === 'object' && Object.prototype.hasOwnProperty.call(definition, 'name')) {
        idxName = definition.unique.name;
      } else if (typeof definition.unique === 'string') {
        idxName = definition.unique;
      } else {
        idxName = `${self.tableName}_${name}_unique`;
      }

      let idx = self.options.uniqueKeys[idxName] || { fields: [] };
      idx = idx || { fields: [], msg: null };
      idx.fields.push(definition.field);
      idx.msg = idx.msg || definition.unique.msg || null;
      idx.name = idxName || false;
      idx.column = name;

      self.options.uniqueKeys[idxName] = idx;
    }

    if (Object.prototype.hasOwnProperty.call(definition, 'validate')) {
      self.Instance.prototype.validators[name] = definition.validate;
    }
  });
  // Create a map of field to attribute names
  this.fieldAttributeMap = Utils._.reduce(this.fieldRawAttributesMap, (map, value, key) => {
    if (key !== value.fieldName) {
      map[key] = value.fieldName;
    }
    return map;
  }, {});

  this.uniqueKeys = this.options.uniqueKeys;

  this._hasStringAttributes = !!this._stringAttributes.length;
  this._isStringAttributes = Utils._.memoize(key => self._stringAttributes.indexOf(key) !== -1);

  this._hasNumberAttributes = !!this._numberAttributes.length;
  this._isNumberAttributes = Utils._.memoize(key => self._numberAttributes.indexOf(key) !== -1);

  this._hasDateAttributes = !!this._dateAttributes.length;
  this._isDateAttributes = Utils._.memoize(key => self._dateAttributes.indexOf(key) !== -1);

  this._hasBooleanAttributes = !!this._booleanAttributes.length;
  this._isBooleanAttributes = Utils._.memoize(key => self._booleanAttributes.indexOf(key) !== -1);

  this._hasBinaryAttributes = !!this._binaryAttributes.length;
  this._isBinaryAttributes = Utils._.memoize(key => self._binaryAttributes.indexOf(key) !== -1);

  this._hasRangeAttributes = !!this._rangeAttributes.length;
  this._isRangeAttributes = Utils._.memoize(key => self._rangeAttributes.indexOf(key) !== -1);

  this._hasComplexAttributes = !!this._complexAttributes.length;
  this._isComplexAttributes = Utils._.memoize(key => self._complexAttributes.indexOf(key) !== -1);

  this._hasGeoAttributes = !!this._geoAttributes.length;
  this._isGeoAttributes = Utils._.memoize(key => self._geoAttributes.indexOf(key) !== -1);

  this._hasSpecialistedAttributes = !!this._specialistedAttributes.length;
  this._isSpecialistedAttributes = Utils._.memoize(key => self._specialistedAttributes.indexOf(key) !== -1);

  this._hasVirtualAttributes = !!this._virtualAttributes.length;
  this._isVirtualAttribute = Utils._.memoize(key => self._virtualAttributes.indexOf(key) !== -1);

  this._hasDefaultValues = !Utils._.isEmpty(this._defaultValues);

  this.attributes = this.rawAttributes;
  this.tableAttributes = Utils._.omit(this.rawAttributes, this._virtualAttributes);

  this.Instance.prototype._hasCustomGetters = Object.keys(this.Instance.prototype._customGetters).length;
  this.Instance.prototype._hasCustomSetters = Object.keys(this.Instance.prototype._customSetters).length;

  Object.keys(attributeManipulation).forEach((key) => {
    if (Object.prototype.hasOwnProperty.call(Instance, key)) {
      this.sequelize.log(`Not overriding built-in method from model attribute: ${key}`);
      return;
    }
    Object.defineProperty(this.Instance.prototype, key, attributeManipulation[key]);
  });

  this.Instance.prototype.rawAttributes = this.rawAttributes;
  this.Instance.prototype.attributes = Object.keys(this.Instance.prototype.rawAttributes);
  this.Instance.prototype._isAttribute = Utils._.memoize(key => self.Instance.prototype.attributes.indexOf(key) !== -1);

  // Primary key convenience variables
  this.primaryKeyAttributes = Object.keys(this.primaryKeys);
  this.primaryKeyAttribute = this.primaryKeyAttributes[0];
  if (this.primaryKeyAttribute) {
    this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;
  }

  this.primaryKeyCount = this.primaryKeyAttributes.length;
  this._hasPrimaryKeys = this.primaryKeyCount > 0;
  this.options.hasPrimaryKeys = this.primaryKeyCount > 0;
  this.hasPrimaryKeys = this.primaryKeyCount > 0;

  this._isPrimaryKey = Utils._.memoize(key => self.primaryKeyAttributes.indexOf(key) !== -1);
};

Model.prototype.removeAttribute = function (attribute) {
  delete this.rawAttributes[attribute];
  this.refreshAttributes();
};

/**
 * 同步数据或配置到es中
 */
Model.prototype.sync = function (options) {
};

Model.prototype.drop = function (options) {};

Model.prototype.dropSchema = function (schema) {};

Model.prototype.schema = function (schema, options) {};

Model.prototype.getTypeName = function (options) {};

Model.prototype.all = function (options) {
  return this.findAll(options);
};

Model.prototype.findAll = async function (options) {
  if (options !== undefined && !Utils._.isPlainObject(options)) {
    throw new Error('The argument passed to findAll must be an options object, use findById if you wish to pass a single primary key value');
  }
  // TODO: Remove this in the next major version (4.0)
  if (arguments.length > 1) {
    throw new Error('Please note that find* was refactored and uses only one options object from now on.');
  }

  const opts = Utils.cloneDeep(options);

  if (!opts.body || !Utils._.size(opts.body)) {
    throw new Error('options.body must be a object!');
  }

  let _sourceInclude = this._sourceInclude;
  const _sourceExclude = this._sourceExclude;

  if (!opts.attributes) {
    _sourceInclude = _sourceInclude.filter(x => opts.attributes(x));
  }

  const searchOptions = Utils._.extend({}, opts, {
    index: this.indexName,
    type: this.typeName,
    _source: this._source,
    _source_include: _sourceInclude,
    _source_exclude: _sourceExclude,
  });

  const { body } = await this.client.search(searchOptions);

  return body;
};

Model.prototype.findById = async function (param, options) {
  // return Promise resolved with null if no arguments are passed
  if ([null, undefined].indexOf(param) !== -1) {
    return Promise.resolve(null);
  }

  const id = Utils._.get(param, `${this.primaryKeyAttribute}`);

  if (!id || !typeof id === 'number' || !typeof id === 'string') {
    throw new Error(`Argument passed to findById is invalid: ${param}`);
  }

  const opts = Utils.cloneDeep(options) || {};

  /* 不用id */
  opts.body = {
    query: {
      term: {
        _id: id,
      },
    },
  };

  const row = await Model.prototype.findOne.call(this, opts);

  return row;
};

Model.prototype.findByPrimary = Model.prototype.findById;

Model.prototype.findOne = async function (options) {
  if (options !== undefined && !Utils._.isPlainObject(options)) {
    throw new Error('The argument passed to findOne must be an options object, use findById if you wish to pass a single primary key value');
  }
  const opts = Utils.cloneDeep(options);

  if (options.size === undefined) {
    opts.size = 1;
  }

  const [row] = await this.findAll(opts);

  return row;
};

Model.prototype.find = Model.prototype.findOne;

Model.prototype.count = async function (options) {
  if (options !== undefined && !Utils._.isPlainObject(options)) {
    throw new Error('The argument passed to findOne must be an options object, use findById if you wish to pass a single primary key value');
  }

  const opts = Utils.cloneDeep(options);

  const countOptions = Utils._.extend({}, opts, {
    index: this.indexType,
    type: this.typeName,
  });

  const { body } = await this.client.count(countOptions);

  return body;
};

Model.prototype.findAndCountAll = Model.prototype.findAndCount;

Model.prototype.max = function (field, options) {};

Model.prototype.min = function (field, options) {};

Model.prototype.sum = function (field, options) {};

Model.prototype.build = function (values, options) {
  if (Array.isArray(values)) {
    return this.bulkBuild(values, options);
  }

  options = Utils._.extend({
    isNewRecord: true,
    $schema: this.$schema,
    $schemaDelimiter: this.$schemaDelimiter,
  }, options || {});

  if (options.attributes) {
    options.attributes = options.attributes.map(attribute => (Array.isArray(attribute) ? attribute[1] : attribute));
  }

  return new this.Instance(values, options);
};

Model.prototype.bulkBuild = function (valueSets, options) {
  options = Utils._.extend({
    isNewRecord: true,
  }, options || {});

  if (options.attributes) {
    options.attributes = options.attributes.map(attribute => (Array.isArray(attribute) ? attribute[1] : attribute));
  }

  return valueSets.map(values => this.build(values, options));
};

Model.prototype.create = function (values, options) {};

Model.prototype.findOrInitialize = Model.prototype.findOrBuild = function (options) {};

Model.prototype.findOrCreate = function (options) {};

Model.prototype.findCreateFind = function (options) {};

Model.prototype.upsert = function (values, options) {};

Model.prototype.insertOrUpdate = Model.prototype.upsert;

Model.prototype.bulkCreate = function (records, options) {};

Model.prototype.truncate = function (options) {};

Model.prototype.restore = function (options) {};

Model.prototype.update = function (values, options) {};

Model.prototype.inspect = function () {
  return this.name;
};

module.exports = Model;
